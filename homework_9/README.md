## Конкурентный парсинг и залив в memcache

### Реализация конкурентности:
- Несколько процессов запускается в самом начале на этапе подсчета общего количества строк во всех файлах
*(Это необходимо для удобства отображения прогресс-бара)*
- Отдельный процесс для обработки каждого файла
- ```memc.set_multi()``` вместо ```memc.set()``` для отправки данных пачками
- Кеширование клиентов в функции ```get_memcache_client()``` для ускорения работы

### Установка зависимостей:
```shell
pip install -r requirements.txt
```

### Запуск:
```shell
# Базовая команда
python memc_load.py
```
```
Параметры запуска:
  -t, --test       Запуск в режиме тестирования
      --dry        Вывод логов уровня INFO
      --pattern    Паттерн поиска файлов, по умолчанию "./*.tsv.gz"
  -w, --workers    Максимальное кол-во обработчиков (процессов), по умолчанию 3
      --not_count  Не подсчитывать общее количество строк
```

#### Примеры:
```shell
# Запуск с 3 обработчиками
python memc_load.py --dry -w 3
```

```shell
# Пропуск этапа подсчета строк
# Запуск происходит быстрей 
# Но нет итогового значения в прогресс-баре, что менее удобно
python memc_load.py --dry --not_count
```

